[
  {
    "objectID": "notebooks/tutorial-instrument.html",
    "href": "notebooks/tutorial-instrument.html",
    "title": "Using Ocean Insight Spectometers",
    "section": "",
    "text": "The spectrometer should be auto detected.\nExposure time to be set to 40 ms.\n\n\nCode\nusing Plots\nusing CSV\nusing DataFrames\n\n\n\n\nCode\nQEpro_cal = CSV.read(\"../data/QEpro_calibration.csv\", DataFrame)\nQEpro_cal\n\n\n1044×3 DataFrame1019 rows omitted\n\n\n\nRow\nwavelengths\ncal_factor\nsensitivity\n\n\n\nFloat64\nFloat64\nFloat64\n\n\n\n\n1\n474.034\n0.000690216\n3.0215\n\n\n2\n474.427\n0.000695744\n3.01961\n\n\n3\n474.82\n0.000689268\n3.07297\n\n\n4\n475.213\n0.000688138\n3.09845\n\n\n5\n475.606\n1.22639e-6\n1751.04\n\n\n6\n475.999\n1.19702e-6\n1804.46\n\n\n7\n476.391\n1.16907e-6\n1857.47\n\n\n8\n476.784\n1.14371e-6\n1908.85\n\n\n9\n477.177\n1.12144e-6\n1959.14\n\n\n10\n477.57\n1.10247e-6\n2008.0\n\n\n11\n477.962\n1.08453e-6\n2056.72\n\n\n12\n478.355\n1.06645e-6\n2103.65\n\n\n13\n478.747\n1.04824e-6\n2151.69\n\n\n⋮\n⋮\n⋮\n⋮\n\n\n1033\n854.489\n2.32563e-6\n1644.02\n\n\n1034\n854.833\n2.3813e-6\n1600.32\n\n\n1035\n855.176\n2.45543e-6\n1545.99\n\n\n1036\n855.52\n2.53909e-6\n1488.27\n\n\n1037\n855.864\n2.61646e-6\n1437.62\n\n\n1038\n856.207\n2.68559e-6\n1395.2\n\n\n1039\n856.551\n2.76499e-6\n1350.68\n\n\n1040\n856.894\n2.87088e-6\n1296.55\n\n\n1041\n857.237\n0.00101976\n3.63456\n\n\n1042\n857.581\n0.00108351\n3.40198\n\n\n1043\n857.924\n0.00108922\n3.375\n\n\n1044\n858.267\n0.00107324\n3.41799\n\n\n\n\n\n\n\n\nCode\n\nplot(QEpro_cal.wavelengths[10:end-10],QEpro_cal.cal_factor[10:end-10],\n    xlabel=\"wavelengths (nm)\",ylabel=\"arb. units\",label=\"overall calibration factor\")\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n\nplot(QEpro_cal.wavelengths[10:end-10],QEpro_cal.sensitivity[10:end-10],\n    xlabel=\"wavelengths (nm)\",ylabel=\"arb. units\",label=\"sensitivity\")"
  },
  {
    "objectID": "notebooks/tutorial-instrument.html#flame-spectrometer",
    "href": "notebooks/tutorial-instrument.html#flame-spectrometer",
    "title": "Using Ocean Insight Spectometers",
    "section": "Flame Spectrometer",
    "text": "Flame Spectrometer\n\n\nCode\ndark = \"../data/led_sources/dark.txt\"\nuv   = \"../data/led_sources/405nm_withdark.txt\"\nblue = \"../data/led_sources/470nm_withdark.txt\"\ngreen= \"../data/led_sources/533nm_withdark.txt\"\nred  = \"../data/led_sources/635nm_withdark.txt\"\n\nfunction sum_gaussians(x, A, mu, sigma, c)\n    return A .* exp.( .- ( (x .- mu)./sigma ).^2 ) .+ c\nend\n\n\nsum_gaussians (generic function with 1 method)\n\n\n\n\nCode\ndf = DataFrame(CSV.File(dark,delim='\\t',skipto=15))\nrename!(df, 1=&gt;:wavelengths, 2=&gt;:counts)\nλs = df.wavelengths\ndark_data = df.counts\n\ndf = DataFrame(CSV.File(uv,delim='\\t',skipto=15))\nrename!(df, 1=&gt;:wavelengths, 2=&gt;:counts)\nuv_data = df.counts\nuv_data .-= dark_data\nuv_data ./= maximum(uv_data)\n\ndf = DataFrame(CSV.File(blue,delim='\\t',skipto=15))\nrename!(df, 1=&gt;:wavelengths, 2=&gt;:counts)\nblue_data = df.counts\nblue_data .-= dark_data\nblue_data ./= maximum(blue_data)\n\ndf = DataFrame(CSV.File(green,delim='\\t',skipto=15))\nrename!(df, 1=&gt;:wavelengths, 2=&gt;:counts)\ngreen_data = df.counts\ngreen_data .-= dark_data\ngreen_data ./= maximum(green_data)\n\ndf = DataFrame(CSV.File(red,delim='\\t',skipto=15))\nrename!(df, 1=&gt;:wavelengths, 2=&gt;:counts)\nred_data = df.counts\nred_data .-= dark_data\nred_data ./= maximum(red_data)\n\n_\n\n\n\n\nCode\nλs_used = λs[10:end-10]\nplot_obj = plot(λs_used,uv_data[10:end-10],color=:magenta,label=\"UV LED\")\nplot!(λs_used,sum_gaussians(λs_used,1,405,17,0),color=:magenta,linestyle=:dash,label=\"UV bell\")\nplot!(λs_used,blue_data[10:end-10],color=:blue,label=\"Blue LED\")\nplot!(λs_used,sum_gaussians(λs_used,1,470,18,0),color=:blue,linestyle=:dash,label=\"Blue bell\")\nplot!(λs_used,green_data[10:end-10],color=:green,label=\"Green LED\")\nplot!(λs_used,sum_gaussians(λs_used,1,533,36,0),color=:green,linestyle=:dash,label=\"Green bell\")\nplot!(λs_used,red_data[10:end-10],color=:red,label=\"Red LED\")\nplot!(λs_used,sum_gaussians(λs_used,1,635,14,0),color=:red,linestyle=:dash,label=\"Red bell\")\n\nxlabel!(plot_obj,\"wavelength (nm)\")\nylabel!(plot_obj,\"normalized amplitude\")\nxlims!(plot_obj,(350,750))\ntitle!(plot_obj,\"Flame Spectrometer\")"
  },
  {
    "objectID": "notebooks/tutorial-instrument.html#qepro-spectrometer",
    "href": "notebooks/tutorial-instrument.html#qepro-spectrometer",
    "title": "Using Ocean Insight Spectometers",
    "section": "QEpro spectrometer",
    "text": "QEpro spectrometer\n\n\nCode\ndark = \"../data/led_sources/qepro_dark.txt\"\nuv   = \"../data/led_sources/qepro_405nm_withdark.txt\"\nblue = \"../data/led_sources/qepro_470nm_withdark.txt\"\ngreen= \"../data/led_sources/qepro_533nm_withdark.txt\"\nred  = \"../data/led_sources/qepro_635nm_withdark.txt\"\n\n\n\n\"../data/led_sources/qepro_635nm_withdark.txt\"\n\n\n\n\nCode\ndf = DataFrame(CSV.File(dark,delim='\\t',skipto=15))\nrename!(df, 1=&gt;:wavelengths, 2=&gt;:counts)\nλs = df.wavelengths\ndark_data = df.counts\n\ndf = DataFrame(CSV.File(uv,delim='\\t',skipto=15))\nrename!(df, 1=&gt;:wavelengths, 2=&gt;:counts)\nuv_data = df.counts\nuv_data .-= dark_data\nuv_data ./= maximum(uv_data)\n\ndf = DataFrame(CSV.File(blue,delim='\\t',skipto=15))\nrename!(df, 1=&gt;:wavelengths, 2=&gt;:counts)\nblue_data = df.counts\nblue_data .-= dark_data\nblue_data ./= maximum(blue_data)\n\ndf = DataFrame(CSV.File(green,delim='\\t',skipto=15))\nrename!(df, 1=&gt;:wavelengths, 2=&gt;:counts)\ngreen_data = df.counts\ngreen_data .-= dark_data\ngreen_data ./= maximum(green_data)\n\ndf = DataFrame(CSV.File(red,delim='\\t',skipto=15))\nrename!(df, 1=&gt;:wavelengths, 2=&gt;:counts)\nred_data = df.counts\nred_data .-= dark_data\nred_data ./= maximum(red_data)\n\n_\n\n\n\n\nCode\nλs_used = λs[10:end-10]\nplot_obj = plot(λs_used,uv_data[10:end-10],color=:magenta,label=\"UV LED 2nd order\")\nplot!(λs_used,sum_gaussians(λs_used,1,405*2,17*2,0),color=:magenta,linestyle=:dash,label=\"UV bell 2nd order\")\nplot!(λs_used,blue_data[10:end-10],color=:blue,label=\"Blue LED\")\nplot!(λs_used,sum_gaussians(λs_used,1,470,18,0),color=:blue,linestyle=:dash,label=\"Blue bell\")\nplot!(λs_used,green_data[10:end-10],color=:green,label=\"Green LED\")\nplot!(λs_used,sum_gaussians(λs_used,1,533,36,0),color=:green,linestyle=:dash,label=\"Green bell\")\nplot!(λs_used,red_data[10:end-10],color=:red,label=\"Red LED\")\nplot!(λs_used,sum_gaussians(λs_used,1,635,14,0),color=:red,linestyle=:dash,label=\"Red bell\")\n\nxlabel!(plot_obj,\"wavelength (nm)\")\nylabel!(plot_obj,\"normalized amplitude\")\ntitle!(plot_obj,\"QEpro Spectrometer\")\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nqepro_solar = \"../data/qepro_solar.csv\"\nflm_solar = \"../data/flm_solar.csv\"\nsixs_solar  = \"../data/6sv_solar.csv\"\n\nsixs_df   = DataFrame(CSV.File(sixs_solar,delim=','))\nflm_df   = DataFrame(CSV.File(flm_solar,delim=','))\nqepro_df = DataFrame(CSV.File(qepro_solar,delim=','))\n\n\n\n\n1044×3 DataFrame1019 rows omitted\n\n\n\nRow\nwavelengths\ncounts\nradiance\n\n\n\nFloat64\nFloat64\nFloat64\n\n\n\n\n1\n474.034\n6.20372e-5\n17.2566\n\n\n2\n474.427\n6.17306e-5\n17.3489\n\n\n3\n474.82\n6.5972e-5\n17.3791\n\n\n4\n475.213\n6.37746e-5\n17.3791\n\n\n5\n475.606\n0.473971\n17.4235\n\n\n6\n475.999\n0.476791\n17.5236\n\n\n7\n476.391\n0.46895\n17.6023\n\n\n8\n476.784\n0.471533\n17.6023\n\n\n9\n477.177\n0.487045\n17.6023\n\n\n10\n477.57\n0.497712\n17.6023\n\n\n11\n477.962\n0.501467\n17.6023\n\n\n12\n478.355\n0.493794\n17.677\n\n\n13\n478.747\n0.487279\n17.7762\n\n\n⋮\n⋮\n⋮\n⋮\n\n\n1033\n854.489\n0.414125\n11.5337\n\n\n1034\n854.833\n0.428303\n11.5337\n\n\n1035\n855.176\n0.435644\n11.5337\n\n\n1036\n855.52\n0.44486\n11.5337\n\n\n1037\n855.864\n0.458307\n11.6159\n\n\n1038\n856.207\n0.468508\n11.7521\n\n\n1039\n856.551\n0.468736\n11.8817\n\n\n1040\n856.894\n0.459855\n11.8817\n\n\n1041\n857.237\n0.000223416\n11.8817\n\n\n1042\n857.581\n0.000105984\n11.8817\n\n\n1043\n857.924\n9.2187e-5\n11.8817\n\n\n1044\n858.267\n9.34135e-5\n11.8817\n\n\n\n\n\n\n\n\nCode\np = plot(sixs_df.wavelengths, sixs_df.radiance./maximum(sixs_df.radiance), label=\"6SV solar spectrum\",color=:Black)\nplot!(flm_df.wavelengths, flm_df.counts, label=\"Flame solar\", color=:Red)\nplot!(qepro_df.wavelengths, qepro_df.counts, label=\"QEpro solar\", color=:Green)\nxlabel!(p,\"wavelength (nm)\")\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n\nflm_cal_factor = flm_df.radiance./maximum(flm_df.radiance) ./ flm_df.counts\nqepro_cal_factor = qepro_df.radiance./maximum(qepro_df.radiance) ./ qepro_df.counts\n\nplot(flm_df.wavelengths, flm_cal_factor, label=\"Flame calibration factor\", color=:Red)\nplot!(qepro_df.wavelengths[10:end-10], qepro_cal_factor[10:end-10], label=\"QEpro calibration factor\", color=:Green)\nxlabel!(\"wavelength (nm)\")\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot(flm_df.wavelengths, flm_cal_factor, yscale=:log,label=\"Flame calibration factor\", color=:Red)\nplot!(qepro_df.wavelengths[10:end-10], qepro_cal_factor[10:end-10], label=\"QEpro calibration factor\", color=:Green)\nxlabel!(\"wavelength (nm)\")\n\n\n┌ Warning: scale log is unsupported with Plots.GRBackend().\n│ Choose from: [:identity, :ln, :log10, :log2]\n└ @ Plots ~/.julia/packages/Plots/sxUvK/src/args.jl:1584"
  },
  {
    "objectID": "notebooks/spectrometers.html",
    "href": "notebooks/spectrometers.html",
    "title": "Spectrometers",
    "section": "",
    "text": "Ocean Insight (formerly Ocean Optics) have a user interface to operate their spectrometers called OceanView. The install files can be found at https://www.oceaninsight.com/support/software-downloads/oceanview-2.0.10-downloads-nolm/. The GUI allows you to inspect the spectra, change settings, and save timestamped data. However, after using it, I found it inconvenient for data analysis because the data files are not immediately accessible. The first data row has one more element than the following rows making it annoying to read into a DataFrame without manual indexing. A few settings are multiple clicks away and it is also not easy to zoom in a specific wavelength range of interest and expand the y-axis scale.\nThere is a Python API to operate their spectrometers which can be easily installed using\npip install seabreeze\nThen there are further install instructions for Linux and Windows (none for MacOS). Follow the install guide here https://python-seabreeze.readthedocs.io/en/latest/install.html. Python packages can be used in Julia with PyCall.jl.\nThis lets you connect to spectrometers, change the exposure and trigger mode, and view the wavelengths and raw counts as a numpy arrays.\n\n\nCode\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n\n\n\nCode\nimport xarray as xr\nimport holoviews as hv\nhv.extension(\"bokeh\", logo=False)\nimport matplotlib.pyplot as plt\n\nfrom datetime import datetime, timezone\nfrom scipy.interpolate import interp1d\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nfrom nbdev.showdoc import show_doc\n\n\n\n\nCode\nfrom fastcore.foundation import patch\nfrom fastcore.dispatch import typedispatch # only types of first two arguments used\nfrom tqdm import tqdm\n\nfrom holoviews import opts\nfrom holoviews.streams import Pipe, Buffer\n\n\n\n\nCode\n\nclass DateTimeBuffer():\n    \"\"\"Records timestamps in UTC time.\"\"\"\n    def __init__(self, n:int = 16) -&gt; None:\n        \"\"\"Initialise a nx1 array and write index\"\"\"\n        self.data = np.arange(n).astype(datetime)\n        self.n = n\n        self.write_pos = 0\n        \n    def __getitem__(self, key:slice) -&gt; datetime:\n        return self.data[key]\n\n    def update(self) -&gt; None:\n        \"\"\"Stores current UTC time in an internal buffer when this method is called.\"\"\"\n        ts = datetime.timestamp(datetime.now())\n        self.data[self.write_pos] = datetime.fromtimestamp(ts, tz=timezone.utc)\n        self.write_pos += 1\n\n        # Loop back if buffer is full\n        if self.write_pos == self.n:\n            self.write_pos = 0\n\nshow_doc(DateTimeBuffer)\n\n\n\n\n\n\n DateTimeBuffer (n:int=16)\n\nRecords timestamps in UTC time.\n\n\n\n\n\nCode\nshow_doc(DateTimeBuffer.update)\n\n\n\n\n\n\n DateTimeBuffer.update ()\n\nStores current UTC time in an internal buffer when this method is called.\n\n\n\n\n\nCode\nfrom typing import Iterable, Union, Callable, List, TypeVar, Generic, Tuple, Optional\n\nclass SpectraBuffer(object):\n    \"\"\"Circular FIFO buffer for spectral measurements\"\"\"\n    def __init__(self, \n                 nbands:int=8, # number of spectral pixels\n                 nlines:int=4, # length of buffer\n                 dtype:type = np.uint16 # data type. raw counts use unit16 but radiance use float32\n                ) -&gt; None:\n        \"\"\"Preallocate data array\"\"\"\n        self.size = (nlines,nbands)\n        self.data = np.zeros(self.size,dtype=dtype)\n        self.write_pos = 0\n        self.read_pos = 0\n        self.slots_left = nlines\n        self.time_buff = DateTimeBuffer(n=nlines)\n        \n    def __getitem__(self, key:slice):\n        return self.data[key]\n    \n    def _inc(self, idx:int) -&gt; int:\n        \"\"\"Increment read/write index with wrap around\"\"\"\n        idx += 1\n        if idx == self.size[0]: idx = 0\n        return idx\n    \n    def is_empty(self) -&gt; bool:\n        return self.slots_left == self.size[0]\n\n    def put(self, line:np.ndarray) -&gt; None:\n        \"\"\"Place spectra into the buffer\"\"\"\n        self.data[self.write_pos,:] = line\n        self.time_buff.update()\n        \n        # if buffer full, update read position to keep track of oldest slot\n        self.slots_left -= 1\n        if self.slots_left &lt; 0:\n            self.slots_left = 0\n            self.read_pos = self._inc(self.read_pos)\n        \n        self.write_pos = self._inc(self.write_pos)\n            \n    def get(self) -&gt; np.ndarray:\n        \"\"\"Reads the oldest (n-1)darray from the buffer\"\"\"\n        if self.slots_left &lt; self.size[0]:\n            val = self.data[self.read_pos,:]\n            self.slots_left += 1\n            self.read_pos = self._inc(self.read_pos)\n            return val\n        else:\n            return None\n        \nshow_doc(SpectraBuffer)\n\n\n\n\n\n\n SpectraBuffer (nbands:int=8, nlines:int=4, dtype:type=&lt;class\n                'numpy.uint16'&gt;)\n\nCircular FIFO buffer for spectral measurements\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nnbands\nint\n8\nnumber of spectral pixels\n\n\nnlines\nint\n4\nlength of buffer\n\n\ndtype\ntype\nuint16\ndata type. raw counts use unit16 but radiance use float32\n\n\nReturns\nNone\n\n\n\n\n\n\n\n\n\n\nCode\nshow_doc(SpectraBuffer.put)\n\n\n\n\n\n\n SpectraBuffer.put (line:numpy.ndarray)\n\nPlace spectra into the buffer\n\n\n\n\n\nCode\nshow_doc(SpectraBuffer.get)\n\n\n\n\n\n\n SpectraBuffer.get ()\n\nReads the oldest (n-1)darray from the buffer\n\n\n\n\n\nCode\n\nclass OceanSpectro(SpectraBuffer):\n    \n    def __init__(self, \n                 exposure:int=40, # exposure time in ms\n                 nlines:int=128,  # length of buffer to preallocate\n                 serial_num:str=\"FLMS01766\", # spectrometer name\n                 radiometric:bool=False,     # radiance stored using floating point or raw counts using integers\n                ) -&gt; None:\n        \"\"\"\n        Initialise the Ocean Insight spectrometers. \n        \"\"\"\n        from seabreeze.spectrometers import Spectrometer\n        try: \n            self.spec = Spectrometer.from_serial_number(serial_num) if serial_num else Spectrometer.from_first_available()\n            self.spec.integration_time_micros(exposure*1000)\n            self._exposure = exposure\n\n            self.wavelengths = self.spec.wavelengths()\n            self.get_spectra()\n        except: \n            print(\"Device already opened. Close with `self.close()` then try again.\")\n            \n        self.n = nlines\n        super().__init__(nbands=len(self.wavelengths),nlines=nlines,dtype=np.float32 if radiometric else np.uint16)\n        \n        \n    @property\n    def exposure(cls):\n        return cls._exposure\n    @exposure.setter\n    def exposure(cls,val):\n        cls._exposure = val\n        cls.spec.integration_time_micros(val*1000)\n\n    def get_spectra(self) -&gt; np.array:\n        \"\"\"Grab spectral measurment\"\"\"\n        self.start()\n        self.last_spectra = self.spec.intensities()\n        self.close()\n        return self.last_spectra\n    \n    def start(self):\n        \"\"\"open spectrometer if closed\"\"\"\n        try: self.spec.open()\n        except: print(\"Please initialise the spectrometer first\")\n        \n    def close(self):\n        \"\"\"close connection to spectrometer\"\"\"\n        self.spec.close()\n        \n    def __repr__(self) -&gt; str:\n        return f\"Spectrometer {self.spec.serial_number}. Exposure time = {self.exposure} ms. Wavelength range = {self.wavelengths[0]:.2f} to {self.wavelengths[-1]:.2f} nm.\"\n    \n    def trigger(self, \n                val:bool=False, # trigger mode\n               ) -&gt; None:\n        \"\"\"guessing these values\"\"\"\n        if val:\n            self.spec.trigger_mode(3)\n        else:\n            self.spec.trigger_mode(0)\n            \n    def collect(self) -&gt; None:\n        \"\"\"Fill up the spectral buffer\"\"\"\n        self.start()\n        for i in tqdm(range(self.n)):\n            self.put( self.spec.intensities() )\n        self.close()\n        \n    def average(self,n:int) -&gt; np.array:\n        \"\"\"Measure `n` spectra and return the average.\"\"\"\n        temp = np.zeros((n,len(self.wavelengths)),dtype=np.float32)\n        self.start()\n        for i in tqdm(range(n)):\n            temp[i,:] = self.spec.intensities()\n        self.close()\n        return np.mean(temp,axis=0)\n        \n    def show(self,\n             plot_lib=\"bokeh\", # plotting backend 'bokeh' or 'matplotlib'\n             savedir:str=None, # save directory string\n            ) -&gt; hv.Curve:     # plot object\n        \"\"\"Plot spectra with option to save plot\"\"\"\n        hv.extension(plot_lib, logo=False)\n        curve = hv.Curve( (self.wavelengths,self.last_spectra) ).opts(xlabel=\"wavelength (nm)\",ylabel=\"counts\")\n        \n        if plot_lib == \"bokeh\":\n            curve = curve.opts(width=1000,height=250)\n        else: # plot_lib == \"matplotlib\"\n            curve = curve.opts(fig_inches=12,aspect=3)\n        if savedir:\n            curve.savefig(f\"{savedir}/{self.time_buff.data[0].strftime('%Y_%m_%d')}/{self.spec.serial_number}_{datetime.now().strftime('%Y_%m_%d-%H_%M_%S')}.pdf\",bbox_inches='tight', pad_inches=0)\n        return curve\n    \n    def waterfall(self,\n                  plot_lib:str=\"bokeh\", # plotting backend 'bokeh' or 'matplotlib'\n                  wavelen_range:tuple=None, # wavelength nm range as tuple (start_nm, end_nm)\n                  savedir:str=None, # save directory string. only possible with plotlib='matplotlib'\n                ) -&gt; hv.Image:      # plot object\n        \"\"\"Plot spectral timeseries\"\"\"\n        hv.extension(plot_lib, logo=False)\n        if not wavelen_range:\n            start_idx = 0\n            end_idx   = len(self.wavelengths)\n        else:\n            start_idx = np.sum(self.wavelengths&lt;wavelen_range[0])\n            end_idx   = np.sum(self.wavelengths&lt;wavelen_range[1])\n        img = hv.Image( self.data[:,start_idx:end_idx] ).opts(colorbar=True,cmap=\"Viridis\")\n        \n        if plot_lib == \"bokeh\":\n            img = img.opts(width=500,height=500)\n        else: # plot_lib == \"matplotlib\"\n            img = img.opts(fig_inches=12,aspect=1.)\n        if savedir:\n            fig, ax = plt.subplots(figsize=(10,10))\n            ax.imshow(self.data[:,start_idx:end_idx]); ax.set_xlabel(\"wavelength index\"); ax.set_ylabel(\"time index\")\n            fig.savefig(f\"{savedir}/{self.spec.serial_number}_{self.time_buff.data[0].strftime('%Y_%m_%d-%H_%M_%S')}.png\",bbox_inches='tight', pad_inches=0)\n        return img\n    \n    def get_live_waterfall(self) -&gt; hv.DynamicMap:\n        \"\"\"Produce a dynamic live image that is updated when `self.runtime` is called.\"\"\"\n        def rescale(x, in_min, in_max, out_min, out_max):\n            return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min\n        self.spec_stream = Pipe([])\n        self.img_dmap = hv.DynamicMap(hv.Image,streams=[self.spec_stream],).opts(xlabel=\"wavelength (nm)\",ylabel=\"seconds ago\")\n        self.img_dmap.opts(xlim=(-0.5,0.5),ylim=(-0.5,0.5),width=500,height=500,cmap=\"plasma\",colorbar=True,toolbar='above',\n             xticks=[(i,int(rescale(i,-0.5,0.5,oo.wavelengths[0],oo.wavelengths[-1]))) for i in np.arange(-0.5,0.51,0.08)],\n             yticks=[(i,np.round(rescale(i,-0.5,0.5,0,oo.n*oo.exposure/1000),1)) for i in np.arange(-0.5,0.51,0.1)],yformatter='%.1f s',\n             title=f\"Spectrometer {oo.spec.serial_number}. Exposure time = {oo.exposure} ms.\")\n        return self.img_dmap\n    \n    def runtime(self,\n                seconds:float=10, # seconds to run the spectrometer\n               ) -&gt; None:\n        \"\"\"Run the spectrometer for `seconds` long and fill up the spectral buffer for `self.img_dmap`.\"\"\"\n        self.start()\n        for i in tqdm(range(int(seconds*1000/self.exposure))):\n            self.put( self.spec.intensities() )\n            temp = self.data.copy()\n            temp[:self.n-self.read_pos,:] = self.data[self.read_pos:,:]\n            temp[self.n-self.read_pos:,:] = self.data[:self.read_pos,:]\n            self.spec_stream.send(temp)\n        self.close()\n\n    \nshow_doc(OceanSpectro)\n\n\n\n\n\n\n OceanSpectro (exposure:int=40, nlines:int=128,\n               serial_num:str='FLMS01766', radiometric:bool=False)\n\nCircular FIFO buffer for spectral measurements\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nexposure\nint\n40\nexposure time in ms\n\n\nnlines\nint\n128\nlength of buffer to preallocate\n\n\nserial_num\nstr\nFLMS01766\nspectrometer name\n\n\nradiometric\nbool\nFalse\nradiance stored using floating point or raw counts using integers\n\n\nReturns\nNone\n\n\n\n\n\n\n\n\n\n\nCode\nshow_doc(OceanSpectro.get_spectra)\n\n\n\n\n\n\n OceanSpectro.get_spectra ()\n\nGrab spectral measurment\n\n\n\n\n\nCode\nshow_doc(OceanSpectro.start)\n\n\n\n\n\n\n OceanSpectro.start ()\n\nopen spectrometer if closed\n\n\n\n\n\nCode\nshow_doc(OceanSpectro.close)\n\n\n\n\n\n\n OceanSpectro.close ()\n\nclose connection to spectrometer\n\n\n\n\n\nCode\nshow_doc(OceanSpectro.trigger)\n\n\n\n\n\n\n OceanSpectro.trigger (val:bool=False)\n\nguessing these values\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nval\nbool\nFalse\ntrigger mode\n\n\nReturns\nNone\n\n\n\n\n\n\n\n\n\n\nCode\nshow_doc(OceanSpectro.collect)\n\n\n\n\n\n\n OceanSpectro.collect ()\n\nFill up the spectral buffer\n\n\n\n\n\nCode\nshow_doc(OceanSpectro.average)\n\n\n\n\n\n\n OceanSpectro.average (n:int)\n\nMeasure n spectra and return the average.\n\n\n\n\n\nCode\nshow_doc(OceanSpectro.show)\n\n\n\n\n\n\n OceanSpectro.show (plot_lib='bokeh', savedir:str=None)\n\nPlot spectra with option to save plot\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nplot_lib\nstr\nbokeh\nplotting backend ‘bokeh’ or ‘matplotlib’\n\n\nsavedir\nstr\nNone\nsave directory string\n\n\nReturns\nCurve\n\nplot object\n\n\n\n\n\n\n\n\nCode\nshow_doc(OceanSpectro.waterfall)\n\n\n\n\n\n\n OceanSpectro.waterfall (plot_lib:str='bokeh', wavelen_range:tuple=None,\n                         savedir:str=None)\n\nPlot spectral timeseries\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nplot_lib\nstr\nbokeh\nplotting backend ‘bokeh’ or ‘matplotlib’\n\n\nwavelen_range\ntuple\nNone\nwavelength nm range as tuple (start_nm, end_nm)\n\n\nsavedir\nstr\nNone\nsave directory string. only possible with plotlib=‘matplotlib’\n\n\nReturns\nImage\n\nplot object\n\n\n\n\n\n\n\n\nCode\nshow_doc(OceanSpectro.get_live_waterfall)\n\n\n\n\n\n\n OceanSpectro.get_live_waterfall ()\n\nProduce a dynamic live image that is updated when self.runtime is called.\n\n\n\n\n\nCode\nshow_doc(OceanSpectro.runtime)\n\n\n\n\n\n\n OceanSpectro.runtime (seconds:float=10)\n\nRun the spectrometer for seconds long and fill up the spectral buffer for self.img_dmap.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nseconds\nfloat\n10\nseconds to run the spectrometer\n\n\nReturns\nNone\n\n\n\n\n\n\n\n\n\n\n\n\nCode\noo = OceanSpectro(nlines=128)\noo.get_spectra()\noo.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\nYou can collect all nlines at once and plot it using OceanSpectro.waterfall\n\n\nCode\noo.collect()\noo.waterfall()\n\n\n100%|█████████████████████████████████████████| 128/128 [00:05&lt;00:00, 24.98it/s]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\nThen you can save it as a HDF5 file.\n\n\nCode\n\n@patch\ndef save(self:OceanSpectro,\n        savedir:str = \".\") -&gt; None:\n    \"\"\"save spectral buffer into HDF5 format\"\"\"\n    attrs = {\"exposure\":self.exposure,\"spectrometer\":self.spec.serial_number}\n    #self.directory = self.directory = f\"{savedir}/{self.time_buff.data[0].strftime('%Y_%m_%d')}\"\n    \n    self.coords = dict(wavelength=([\"wavelength\"],self.wavelengths),\n                       time=([\"time\"],self.time_buff.data.astype(np.datetime64)) )\n    self.nc = xr.Dataset(data_vars=dict(datacube=([\"time\",\"wavelength\"],self.data)),\n                             coords=self.coords, \n                             attrs=attrs)\n    self.nc.time.attrs[\"long_name\"]   = \"UTC time\"\n    self.nc.time.attrs[\"description\"] = \"UTC time for each measurement\"\n    self.nc.wavelength.attrs[\"long_name\"]   = \"wavelength_nm\"\n    self.nc.wavelength.attrs[\"units\"]       = \"nanometers\"\n    self.nc.wavelength.attrs[\"description\"] = \"wavelength in nanometers.\"\n    \n    self.nc.to_netcdf(f\"{savedir}/{self.spec.serial_number}_{self.time_buff.data[0].strftime('%Y_%m_%d-%H_%M_%S')}_spectra.h5\")\n    self.waterfall(plot_lib=\"matplotlib\",savedir=savedir)\n\nshow_doc(OceanSpectro.save)\n\n\n\n\n\n\n OceanSpectro.save (savedir:str='.')\n\nsave spectral buffer into HDF5 format\n\n\n\n\n\nCode\noo.save(\"../../data/test/\")\n\n\n/var/folders/fn/jjhdyhvd3_98hz2qmws897lw0000gn/T/ipykernel_13769/1695057546.py:9: DeprecationWarning: parsing timezone aware datetimes is deprecated; this will raise an error in the future\n  time=([\"time\"],self.time_buff.data.astype(np.datetime64)) )\n\n\n\n\n\n\n\n\n\n\n\n\nAnd load the save file back up.\n\n\nCode\n\n@patch\ndef load(self:OceanSpectro,\n        fname:str, # path to h5 or netcdf4 file\n        ) -&gt; None:\n    ds = xr.open_dataset(fname)\n    self._exposure = ds.attrs[\"exposure\"]\n    self.wavelengths = ds.coords[\"wavelength\"]\n    self.n = ds.datacube.shape[0]\n    self.size = ds.datacube.shape\n    self.data = ds.datacube.data\n    self.write_pos = ds.datacube.shape[1]-1\n    self.read_pos  = 0\n    self.slots_left = self.n\n    self.time_buff.data = ds.coords[\"time\"]\n\nshow_doc(OceanSpectro.load)\n\n\n\n\n\n\n OceanSpectro.load (fname:str)\n\n\n\n\n\nType\nDetails\n\n\n\n\nfname\nstr\npath to h5 or netcdf4 file\n\n\nReturns\nNone\n\n\n\n\n\n\n\n\n\nCode\noo2 = OceanSpectro()\noo2.load(\"../../data/test/FLMS01766_2023_11_11-02_29_16_spectra.h5\")\noo2.waterfall()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\nYou can also view an updating waterfall plot by running the following two code cells together (in order).\n\n\nCode\noo.get_live_waterfall()\n\n\n\n\n\n\n  \n\n\n\n\n\n\nCode\noo.runtime(10) # seconds\n\n\n100%|█████████████████████████████████████████| 250/250 [00:14&lt;00:00, 17.73it/s]\n\n\n\n\n\n\n\nCode\n@patch\ndef measure_dark(self:OceanSpectro,\n                fname:str=None) -&gt; None:\n    x = self.average(100)\n    self.dark_df = pd.DataFrame(x,columns=[\"dark\"])\n    if savedir:\n        self.dark_df.to_csv(fname)\n    return self.dark_df\n\nshow_doc(OceanSpectro.measure_dark)\n\n\n\n\n\n\n\n\n\ndark\n\n\n\n\n0\n16.990566\n\n\n1\n29068.427734\n\n\n2\n2367.610107\n\n\n3\n2321.225586\n\n\n4\n2317.972900\n\n\n...\n...\n\n\n2043\n2747.008545\n\n\n2044\n2742.784912\n\n\n2045\n2741.450684\n\n\n2046\n2741.450684\n\n\n2047\n2741.450684\n\n\n\n\n2048 rows × 1 columns\n\n\n\n\n\n\n\n\nCode\n@patch\ndef load_dark(self:OceanSpectro,\n              fname:str) -&gt; None:\n    self.dark_df = pd.read_csv(fname)\n\nshow_doc(OceanSpectro.load_dark)\n\n\n\n\n\n\n OceanSpectro.load_dark (fname:str)\n\n\n\n\n\n\nCode\n@patch\ndef measure_sphere(self:OceanSpectro,\n                   fname:str=None) -&gt; None:\n    x = self.average(100)\n    self.sphere_df = pd.DataFrame(x,columns=[\"sphere\"])\n    if savedir:\n        self.sphere_df.to_csv(fname)\n    return self.sphere_df\n\nshow_doc(OceanSpectro.measure_sphere)\n\n\n\n\n\n\n OceanSpectro.measure_sphere (fname:str=None)\n\n\n\n\n\n\nCode\n@patch\ndef load_sphere(self:OceanSpectro,\n                fname:str) -&gt; None:\n    self.sphere_df = pd.read_csv(fname)\n    \nshow_doc(OceanSpectro.load_sphere)\n\n\n\n\n\n\n OceanSpectro.load_sphere (fname:str)\n\n\n\n\n\n\nCode\n@patch\ndef correct_dark(self:OceanSpectro,\n                ) -&gt; None:\n    \n    pass\n\nshow_doc(OceanSpectro.correct_dark)\n\n\n\n\nCode\n@patch\ndef correct_sphere(self:OceanSpectro,\n                ) -&gt; None:\n    pass\n\nshow_doc(OceanSpectro.correct_sphere)\n\n\n\n\nCode\n@patch\ndef dn2rad(self:OceanSpectro,\n                ) -&gt; None:\n    # temp buff record\n    # x = self.correct_sphere( self.correct_dark() )\n    pass\n\nshow_doc(OceanSpectro.dn2rad)"
  },
  {
    "objectID": "notebooks/spectrometers.html#measuring-dark-current",
    "href": "notebooks/spectrometers.html#measuring-dark-current",
    "title": "Spectrometers",
    "section": "",
    "text": "Code\n@patch\ndef measure_dark(self:OceanSpectro,\n                fname:str=None) -&gt; None:\n    x = self.average(100)\n    self.dark_df = pd.DataFrame(x,columns=[\"dark\"])\n    if savedir:\n        self.dark_df.to_csv(fname)\n    return self.dark_df\n\nshow_doc(OceanSpectro.measure_dark)\n\n\n\n\n\n\n\n\n\ndark\n\n\n\n\n0\n16.990566\n\n\n1\n29068.427734\n\n\n2\n2367.610107\n\n\n3\n2321.225586\n\n\n4\n2317.972900\n\n\n...\n...\n\n\n2043\n2747.008545\n\n\n2044\n2742.784912\n\n\n2045\n2741.450684\n\n\n2046\n2741.450684\n\n\n2047\n2741.450684\n\n\n\n\n2048 rows × 1 columns\n\n\n\n\n\n\n\n\nCode\n@patch\ndef load_dark(self:OceanSpectro,\n              fname:str) -&gt; None:\n    self.dark_df = pd.read_csv(fname)\n\nshow_doc(OceanSpectro.load_dark)\n\n\n\n\n\n\n OceanSpectro.load_dark (fname:str)\n\n\n\n\n\n\nCode\n@patch\ndef measure_sphere(self:OceanSpectro,\n                   fname:str=None) -&gt; None:\n    x = self.average(100)\n    self.sphere_df = pd.DataFrame(x,columns=[\"sphere\"])\n    if savedir:\n        self.sphere_df.to_csv(fname)\n    return self.sphere_df\n\nshow_doc(OceanSpectro.measure_sphere)\n\n\n\n\n\n\n OceanSpectro.measure_sphere (fname:str=None)\n\n\n\n\n\n\nCode\n@patch\ndef load_sphere(self:OceanSpectro,\n                fname:str) -&gt; None:\n    self.sphere_df = pd.read_csv(fname)\n    \nshow_doc(OceanSpectro.load_sphere)\n\n\n\n\n\n\n OceanSpectro.load_sphere (fname:str)\n\n\n\n\n\n\nCode\n@patch\ndef correct_dark(self:OceanSpectro,\n                ) -&gt; None:\n    \n    pass\n\nshow_doc(OceanSpectro.correct_dark)\n\n\n\n\nCode\n@patch\ndef correct_sphere(self:OceanSpectro,\n                ) -&gt; None:\n    pass\n\nshow_doc(OceanSpectro.correct_sphere)\n\n\n\n\nCode\n@patch\ndef dn2rad(self:OceanSpectro,\n                ) -&gt; None:\n    # temp buff record\n    # x = self.correct_sphere( self.correct_dark() )\n    pass\n\nshow_doc(OceanSpectro.dn2rad)"
  },
  {
    "objectID": "notebooks/tutorial-quarto.html",
    "href": "notebooks/tutorial-quarto.html",
    "title": "How to contribute",
    "section": "",
    "text": "This repository is a collection of Jupyter notebooks that is autogenerated into this documentation website using Quarto. These notebooks can be run using VScode or Jupyter Lab. The purpose of this guide is to get you setup using Julia in Juypyter notebooks and inspire you to create a documentation site of your own."
  },
  {
    "objectID": "notebooks/tutorial-quarto.html#quarto-commands",
    "href": "notebooks/tutorial-quarto.html#quarto-commands",
    "title": "How to contribute",
    "section": "Quarto Commands",
    "text": "Quarto Commands\nAssuming you now have a repo setup (or using this one), you can preview the documentation site locally by running the following in a repository directory.\nquarto preview\nTo update the deployed website, you can run\nquarto publish gh-pages\n\n\n\n\n\n\nTip\n\n\n\nYou can also litter your documentation with coloured callout boxes like this one. See https://quarto.org/docs/authoring/callouts.html for how to do these."
  },
  {
    "objectID": "notebooks/tutorial-quarto.html#jupyter-lab-packages",
    "href": "notebooks/tutorial-quarto.html#jupyter-lab-packages",
    "title": "How to contribute",
    "section": "Jupyter Lab Packages",
    "text": "Jupyter Lab Packages\nTo use Julia in Jupyter, you will also need some Julia specific packages installed. These can be added using\n\nusing Pkg\nPkg.add(\"Revise\")\nPkg.add(\"IJulia\")\nPkg.build(\"IJulia\") # add to Jupyter kernel list\n\nIf somehow old Julia versions appear in Jupyter that you want gone, you can use\njupyter kernelspec list\nto find the offending versions then remove them using\njupyter kernelspec uninstall julia-X.Y\nreplacing X.Y with the version number."
  },
  {
    "objectID": "notebooks/tutorial-quarto.html#vscode-extensions",
    "href": "notebooks/tutorial-quarto.html#vscode-extensions",
    "title": "How to contribute",
    "section": "VScode extensions",
    "text": "VScode extensions\nTo use Julia in VScode, you will need to install the extensions julia and julia-vscode."
  },
  {
    "objectID": "notebooks/about.html",
    "href": "notebooks/about.html",
    "title": "About",
    "section": "",
    "text": "This is a project to experimentally verify fluorescence yields in leaves and to model the dynamics under light sources across the visible spectrum.\nThe team consists of Yiwei Mao, Christian Frankenberg, Yujie Wang, and Yinon Bar-On. Contributions to the project can be made to our Github repository."
  },
  {
    "objectID": "notebooks/tutorial-julia.html",
    "href": "notebooks/tutorial-julia.html",
    "title": "Julia for the beginner*",
    "section": "",
    "text": "I am approaching this as someone familiar with programming in Python which I think is most people. This guide is a summary of my learning experience in the hope that it is helpful for others learning Julia for the first time."
  },
  {
    "objectID": "notebooks/tutorial-julia.html#revise.jl",
    "href": "notebooks/tutorial-julia.html#revise.jl",
    "title": "Julia for the beginner*",
    "section": "Revise.jl",
    "text": "Revise.jl\nRevise.jl is a Julia package that provides a way to update function definitions in a running Julia session. This package is particularly useful during development, where you might iteratively change your code and want those changes to be reflected in your session without restarting it.\nThe key feature of Revise.jl is that it can track changes in your source code and, upon saving the file, automatically update those changes in the Julia environment. This means that after editing your Julia source files, the changes can be immediately tested in the REPL, Jupyter notebook, or other interactive environments without the need for manual recompilation or restarting Julia.\nPkg.add(\"Revise\")\n\nusing Revise"
  },
  {
    "objectID": "notebooks/tutorial-julia.html#other-julia-resources",
    "href": "notebooks/tutorial-julia.html#other-julia-resources",
    "title": "Julia for the beginner*",
    "section": "Other Julia resources",
    "text": "Other Julia resources\nFor a summary of Julia features, check out https://cheatsheet.juliadocs.org/.\nI went through the MIT course introducing Julia which was excellently designed and motivated. Highly recommended!\nThe course is called Introduction to Computational Thinking https://computationalthinking.mit.edu/Fall23/ and I think it is well titled as I certainly had to develop a different way of thinking to code in Julia. Below are some major points that changes the way you code."
  },
  {
    "objectID": "notebooks/tutorial-julia.html#structs-are-immutable-by-default",
    "href": "notebooks/tutorial-julia.html#structs-are-immutable-by-default",
    "title": "Julia for the beginner*",
    "section": "Structs are immutable by default",
    "text": "Structs are immutable by default\nA struct datatype is like a Python class with only immutable attributes. It defines a data type. To make a struct mutable, simply use mutable struct instead of struct.\n\n# Define a mutable struct named Person\nmutable struct Person\n    name::String\n    age::Int\nend\n\n# Create an instance of Person\njulia = Person(\"Julia\", 30)\n\n# Since it's mutable, we can change the fields after creation\njulia.age = 31  # This is allowed and the age is updated to 31\n\nprintln(\"Name: \", julia.name, \", Age: \", julia.age)  # Outputs: Name: Julia, Age: 31\n\nName: Julia, Age: 31"
  },
  {
    "objectID": "notebooks/tutorial-julia.html#more-macros",
    "href": "notebooks/tutorial-julia.html#more-macros",
    "title": "Julia for the beginner*",
    "section": "More macros",
    "text": "More macros\nHere are some more of the commonly used macros in Julia\n\n@macroexpand: This macro shows the result of the macro expansion, which is useful for understanding what the macro does to your code.\n@assert: This is used for assertions in your code. It throws an AssertionError if the condition is not met.\n@test: Part of Julia’s standard library Test, this macro is used for writing test cases.\n@inline / @noinline: These control whether the compiler should inline a particular function, which can sometimes improve or worsen performance.\n@eval: Used to evaluate an expression in the global scope, which can be useful in metaprogramming for generating code programmatically.\n@everywhere: In a distributed computing environment, this macro is used to define a function or variable in every process of a Julia session.\n@unpack / @pack: Provided by the Parameters.jl package, these macros are used for unpacking and packing variables into structures, which is particularly useful when dealing with many parameters or settings.\n\n\nusing Distributed\n\n# Add worker processes for parallel computation\naddprocs(4)  # Assuming you want to add 4 worker processes\n\n# A simple function to do some work, e.g., a costly computation\n@everywhere function do_work(x)\n    sleep(0.1)  # Simulating some work by sleeping for 0.1 seconds\n    return x^2\nend\n\n\n# Use @distributed to parallelize the loop\nresults = @distributed (+) for i in 1:100\n    do_work(i)\nend\n\n# 'results' will contain the sum of the squares of numbers from 1 to 100\nprintln(results)\n\n338350\n\n\nIn the above example, the @distributed macro is used with a reduction operation (+) that specifies how the results from each iteration should be combined—in this case, they are summed. The loop runs in parallel across the available worker processes, and each process runs a portion of the loop iterations. By using @everywhere, the do_work function is defined across all processes."
  },
  {
    "objectID": "notebooks/LeafSpectroscopy.html",
    "href": "notebooks/LeafSpectroscopy.html",
    "title": "LeafSpectroscopy",
    "section": "",
    "text": "Code\nusing Pkg; Pkg.activate(\".\")\n\n\n\n\nCode\nmodule LeafSpectroscopy\n\n#export MyType\n# stuff\nend\n\n\n\n\nCode\nfunction filepath2dataframe(fname)\n    return 0\nend\n\nfunction remove_dark(dark_fname)\n    return 0\nend\n\nfunction apply_calibration(cal_fname)\n    return 0\nend\n\nfunction find_pulses(dataframe)\n    return 0\nend\n\nstruct Yields\n    F_0::Float64\n    F_m::Float64\nend\n\nfunction calc_yields(dataframe)\n    return 0\nend\n\nfunction show_yields(dataframe)\n    return 0\nend\n\nfunction calc_Fv(yields)\n    return 0\nend\n\n\n\ncalc_Fv (generic function with 1 method)"
  },
  {
    "objectID": "notebooks/intro.html",
    "href": "notebooks/intro.html",
    "title": "Introduction",
    "section": "",
    "text": "Welcome to LeafSpectroscopy.jl\nCode\nusing Pkg; Pkg.activate(\".\")"
  },
  {
    "objectID": "notebooks/intro.html#photon-flux-for-modulating-beam",
    "href": "notebooks/intro.html#photon-flux-for-modulating-beam",
    "title": "Introduction",
    "section": "Photon Flux for modulating beam",
    "text": "Photon Flux for modulating beam\nThe photon flux (or intensity?) \\(n\\) in μmol/m\\(^2\\)/s is given by \\[\n    n = \\frac{IV}{A N_A hc} \\lambda\n\\] where \\(I\\) is current, \\(V\\) is the forward voltage, \\(A\\) is the illumination area, \\(N_A=6.022\\times 10^{23}\\) is Avogadro’s constant, \\(h=6.626\\times 10^{-34}\\) J\\(\\cdot\\)s\\(^{-1}\\) is Planck’s constant, \\(c=299792458\\) m\\(\\cdot\\)s\\(^{-1}\\) is the speed of light, and \\(\\lambda\\) is the wavelength.\n\n\nCode\nλ = [405,470,533,635].*1e-9 # nm\nI = 10e-3 # A\nV = [3.5, 3.2, 3.4, 2.2] # V\nN_A = 6.022e23\nh = 6.626e-34 # J/s\nc = 299792458 # m/s\nA = π*0.002^2 # m²\n\nn = I.*V.*λ ./ (A*N_A*h*c)\n\nn*1e6\n\n\n4-element Vector{Float64}:\n  9429.753016929846\n 10005.184153412689\n 12055.448618892602\n  9293.379163774951\n\n\nHowever, not all the light from the LED makes it through the fiber.\nAssuming the fiber core is 60 μm, most of the LED light is lost. Since the LED SMA diameter is 3 mm, around (60/3000)^2 of the LED output photon flux is able to make it through a single fiber. Also, assume that the optical efficiency of the fiber is around 90%. Therefore, the photon intensity for the blue fiber in μmol/m^2/s is\n\n\nCode\nusing DataFrames\nnn = n*1e6 * (60/3000)^2 * 0.9\ndf = DataFrame(wavelength_nm=λ*1e9, photon_flux_umol=nn)\ndf\n\n\n4×2 DataFrame\n\n\n\nRow\nwavelength_nm\nphoton_flux_umol\n\n\n\nFloat64\nFloat64\n\n\n\n\n1\n405.0\n3.39471\n\n\n2\n470.0\n3.60187\n\n\n3\n533.0\n4.33996\n\n\n4\n635.0\n3.34562\n\n\n\n\n\n\n\n\nCode"
  }
]